# ESP32 Cooperative Multitasking OS Architecture Plan

## Current State

- Bootloader integration with app/partition info display
- Basic hardware drivers (GPIO, I2C, UART, OLED)
- Monolithic main loop with blocking operations
- Basic interrupt stub (DefaultHandler) but no real interrupt management

## Architecture Goals

- Cooperative multitasking: tasks voluntarily yield control
- Production-ready foundation for specific applications
- Clean separation between kernel and user space
- Interrupt-driven hardware handling

## Implementation Plan (Prioritized)

### Phase 1: Interrupt System & Timer Infrastructure (FOUNDATION - Start Here)

**Why this first?** Everything else depends on interrupts and timing. Without proper interrupt handling, hardware events can't be processed, and without a system tick, we can't implement time-based operations like sleep() or timeouts.

**1.1 Interrupt Management (`src/interrupts.rs`)**

- **What it does:** Manages all hardware interrupts (GPIO, UART, I2C, timers, etc.)
- **Why needed:** Hardware events (button presses, UART data, timer ticks) need to trigger code execution
- **How we build it:**
                                - Replace stub DefaultHandler with proper interrupt dispatcher that routes interrupts to registered handlers
                                - Create interrupt vector table registration system (ESP32 has ~32 interrupt sources)
                                - Implement interrupt enable/disable primitives (needed for critical sections)
                                - Add interrupt priority management (ESP32 supports 5 priority levels)
                                - Create interrupt handler registration API so drivers can register their handlers

**1.2 System Timer/Tick (`src/timer.rs` - new module)**

- **What it does:** Provides system-wide timekeeping and periodic interrupts
- **Why needed:** 
                                - Scheduler needs to know when to wake sleeping tasks
                                - Tasks need `sleep()` functionality
                                - System needs time-based delays and timeouts
- **How we build it:**
                                - Configure ESP32 Timer0 or Timer1 peripheral for periodic interrupts (1ms or 10ms intervals)
                                - Implement timer interrupt handler that increments a global tick counter
                                - Create system tick counter (32-bit with overflow handling, or 64-bit if memory allows)
                                - Provide `get_ticks()` and `ticks_to_ms()` utility functions
                                - This becomes the "heartbeat" of the OS

**1.3 Critical Section Management (`src/sync.rs` - new module)**

- **What it does:** Prevents interrupts from interrupting critical code sections
- **Why needed:** When scheduler modifies task queues or heap allocator modifies free lists, we can't allow interrupts to corrupt shared data structures
- **How we build it:**
                                - Implement `enter_critical()` and `exit_critical()` functions using ESP32's interrupt disable
                                - Create `CriticalSection` guard type (RAII pattern) that automatically restores interrupts when dropped
                                - Use this everywhere we access shared kernel data structures

### Phase 2: Task Scheduler (Cooperative) - Core OS Functionality

**Why this second?** This is the heart of the OS - it enables multitasking. Once we have interrupts and timers, we can build the scheduler.

**2.1 Task Control Block (`src/task.rs` - new module)**

- **What it does:** Represents a single task/thread in the system
- **Why needed:** Each task needs its own stack, state, and context to be saved/restored
- **How we build it:**
                                - Define `Task` struct with:
                                                                - Stack pointer (where task's stack is in memory)
                                                                - Stack size (for overflow detection)
                                                                - Task state (Ready, Running, Blocked, Suspended)
                                                                - Task ID/name (for debugging)
                                                                - Priority (determines order in ready queue)
                                                                - Saved CPU registers (when task is not running)
                                - Implement context saving/restoring functions (save all CPU registers to Task struct, restore them when switching back)

**2.2 Cooperative Scheduler (`src/scheduler.rs` - new module)**

- **What it does:** Manages which task runs when, switches between tasks
- **Why needed:** Enables multitasking - multiple tasks appear to run simultaneously
- **How we build it:**
                                - Round-robin ready queue (FIFO queue of tasks ready to run)
                                - `yield()` function: current task voluntarily gives up CPU, scheduler picks next task
                                - `spawn_task()` API: creates new task with function pointer and stack, adds to ready queue
                                - `sleep(ticks)` function: moves task from ready queue to blocked queue, sets wake-up time
                                - Timer interrupt handler checks blocked queue and moves expired tasks back to ready queue
                                - Context switching: save current task's registers, load next task's registers, jump to its code

**2.3 Kernel Integration**

- **What it does:** Wires everything together, converts monolithic main() into OS
- **Why needed:** Need to initialize scheduler and convert existing code into tasks
- **How we build it:**
                                - Refactor `main.rs` to initialize scheduler early
                                - Convert current main loop into initial "kernel task" or "idle task"
                                - Move hardware initialization to kernel startup (before scheduler starts)
                                - Create example user tasks (e.g., LED blink task, display update task) to demonstrate multitasking

### Phase 3: Memory Management - Enable Dynamic Allocation

**Why this third?** Tasks need dynamic memory allocation for stacks and data structures. Heap allocator enables this.

**3.1 Heap Allocator (`src/heap.rs` - new module)**

- **What it does:** Manages dynamic memory allocation (like malloc/free)
- **Why needed:** 
                                - Tasks need to allocate stacks dynamically
                                - Applications need heap for data structures
                                - Enables Rust's `alloc` crate (Vec, String, Box, etc.)
- **How we build it:**
                                - Simple linked list allocator: track free blocks in a linked list
                                - Use ESP32's available SRAM (typically 520KB total, ~200KB free after static allocations)
                                - Provide `alloc(size)` and `dealloc(ptr)` functions
                                - Integrate with Rust's `GlobalAlloc` trait so `alloc` crate works
                                - Add heap statistics (used/free memory) for debugging
                                - Must be thread-safe (use critical sections)

**3.2 Stack Management**

- **What it does:** Allocates and manages task stacks
- **Why needed:** Each task needs its own stack for local variables and function calls
- **How we build it:**
                                - Allocate task stacks from heap (or dedicated region if preferred)
                                - Add stack overflow detection (stack canaries - write magic value at end of stack, check it periodically)
                                - Stack size configuration per task (default 4KB, configurable)

### Phase 4: Device Driver Abstraction - Clean Hardware Access

**Why this fourth?** Once we have multitasking, we need to make hardware access safe and abstracted.

**4.1 Driver Framework (`src/drivers/mod.rs` - new module)**

- **What it does:** Provides unified interface for all hardware drivers
- **Why needed:** 
                                - Prevents multiple tasks from accessing same hardware simultaneously
                                - Provides consistent API across different hardware types
                                - Enables future expansion (device nodes, permissions, etc.)
- **How we build it:**
                                - Define `Driver` trait with `init()`, `read()`, `write()` methods
                                - Create driver registration system (drivers register themselves at startup)
                                - Implement device node concept (optional, for future expansion to user-space drivers)

**4.2 Refactor Existing Drivers**

- **What it does:** Wraps existing GPIO, I2C, UART, OLED code in driver abstraction
- **Why needed:** Makes hardware access interrupt-safe and task-safe
- **How we build it:**
                                - Wrap GPIO, I2C, UART, OLED in driver structs implementing Driver trait
                                - Add mutexes or critical sections to prevent concurrent access
                                - Add driver initialization ordering (I2C before OLED, etc.)

### Phase 5: System Calls & API - User Interface

**Why this fifth?** Provides clean API for applications to use OS services.

**5.1 System Call Interface (`src/syscall.rs` - new module)**

- **What it does:** Provides controlled interface between user code and kernel
- **Why needed:** Applications need to call kernel functions (spawn task, sleep, allocate memory)
- **How we build it:**
                                - Define system call numbers (enum with values like SYS_SPAWN, SYS_SLEEP, SYS_ALLOC)
                                - Implement syscall dispatcher (switch statement that routes syscalls to kernel functions)
                                - Create user-facing API functions (e.g., `os::spawn()`, `os::sleep()`) that call into kernel via syscall

**5.2 Kernel Services**

- **What it does:** Exposes kernel functionality to applications
- **Why needed:** Applications need to use OS features
- **How we build it:**
                                - Time services: `get_time()`, `sleep(ms)`
                                - Task services: `spawn_task()`, `yield()`, `get_task_id()`
                                - Memory services: `alloc()`, `free()` (if exposed to users, or just use Rust alloc)

### Phase 6: Filesystem (FUTURE - Not in Initial Implementation)

**What it would do:** Provides file-based storage on flash partitions

**Why it's future:** Not needed for initial OS functionality, can be added when storage requirements arise

**How we'd build it:**

- Raw flash partition access (read/write blocks to flash)
- Simple filesystem layer (SPIFFS or LittleFS) for file operations
- File API: `open()`, `read()`, `write()`, `close()`
- Mount/unmount partition management

## File Structure After Implementation

```
src/
  - main.rs              (Kernel entry, initialization, main kernel task)
  - interrupts.rs        (Interrupt management, vector table)
  - timer.rs             (System timer, tick counter)
  - sync.rs              (Critical sections, synchronization)
  - task.rs              (Task control block, context switching)
  - scheduler.rs         (Cooperative scheduler, task queues)
  - heap.rs              (Heap allocator)
  - drivers/
    - mod.rs             (Driver trait, registration)
    - gpio.rs            (GPIO driver wrapper)
    - i2c.rs             (I2C driver wrapper)
    - uart.rs            (UART driver wrapper)
    - oled.rs            (OLED driver wrapper)
  - syscall.rs           (System call interface)
  - bootloader_info.rs   (Keep as-is)
  - frames.rs            (Keep as-is)
  - ml.rs                (Keep as-is, may need scheduler integration)
  - gpio.rs              (May be moved to drivers/)
  - i2c.rs               (May be moved to drivers/)
  - uart.rs              (May be moved to drivers/)
  - oled.rs              (May be moved to drivers/)
```

## Implementation Order (Priority)

1. **Interrupt System** - Foundation for everything
2. **Timer/Tick** - Required for scheduler timing
3. **Critical Sections** - Needed for safe shared data access
4. **Task & Scheduler** - Core OS functionality
5. **Memory Management** - Enable dynamic allocation
6. **Driver Abstraction** - Clean up hardware access
7. **System Calls** - User-facing API
8. **Filesystem** - Future enhancement

## Key Design Decisions

- **Cooperative Scheduling**: Tasks must explicitly yield; no preemption
- **Stack-based Context Switching**: Save/restore CPU registers on task switch
- **Interrupt-driven I/O**: Hardware events trigger interrupts, not polling
- **No MMU**: ESP32 doesn't have memory protection, so all tasks share address space
- **Static Configuration**: Task count, stack sizes configured at compile time (heapless)
- **Priority-based Ready Queue**: Higher priority tasks run first, but still cooperative

## Testing Strategy

- Create multiple simple tasks (LED blink, counter, display update)
- Verify cooperative yielding works
- Test interrupt handling doesn't break scheduler
- Verify timer-based sleep functionality
- Test memory allocation/deallocation
- Ensure no stack overflows or memory leaks